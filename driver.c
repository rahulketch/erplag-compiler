/*
Group 8
Rahul Sharma	 2013B5A7713P
Srajan Jain 	 2013B5A7810P
*/

#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <stdarg.h>
#include <stdio.h>
#include "parserDef.h"
#include "lexer.h"
#include "parser.h"
#include "ast.h"
#include "symboltable.h"
#include "codegen.h"



int main(int argc,char* argv[]){
	int err_flag_parse;
	printf("\n\nLevel 4: Symbol table, type Checking, Semantic Rules module work.\n\n");
   // printf("1) FIRST and FOLLOW sets automated\n2)Both lexical and syntax analysis modules implemented\n");
   // printf("3) Test case 1,3,4 working perfectly. Test case 2 has not been handled as per discussion with the instructor\n");
   // printf("4) Parse Tree Generated\n");
   if(argc!=3){
      printf("Incorrect arguments\nTerminating driver\n");
      exit(1);
   }
   // char file2[100];
   // strcpy(file2,"testfile.txt");
   int choice;


   int i,j,currentBuf=0;
   long unsigned int lineNo = 1;
   char *buf[2], *forward, *begin;
   
   
   tokenInfo* temp;
   rule* rules[no_rules];
   populateRules(rules);
   
   term_sets* termSetsArr[no_tnt];
   
   for(i=0;i<no_tnt;i++){
      termSetsArr[i] = (term_sets*)malloc(sizeof(term_sets));
      termSetsArr[i]->FIRST = 0;
      termSetsArr[i]->FOLLOW = 0;
      termSetsArr[i]->token = (tnt)i;
   }
   int** parseTable;
   parseTable = (int**)malloc(sizeof(int*)*no_non_terminals);
   for(i=0;i<no_non_terminals;i++){
      parseTable[i] = (int*)malloc(sizeof(int)*no_terminals);
   }
   for(i=0;i<no_non_terminals;i++){
      for(j=0;j<no_terminals;j++){
         parseTable[i][j]=-1; //initializing parse table
      }
   }
   populateFIRST(rules,termSetsArr);
   populateFOLLOW(rules,termSetsArr);
   populateParseTable(parseTable,rules,termSetsArr);
   treeNode x; 
   long int parseTreeSize,ASTsize;
	moduleScopeInfo some;
	int parse_flag = 0;
	int ast_flag = 0;
	long int no_parse,no_ast;
   while(1){
      buf[0] = (char*)malloc(sizeof(char)*(bufferSize+1));
      buf[0][bufferSize]='\0';
      buf[1] = (char*)malloc(sizeof(char)*(bufferSize+1));
      buf[1][bufferSize]='\0';
      begin = buf[0];
      forward = buf[0];
      printf("\n\nPress\n1 For printing the token list generated by the lexer (on the console)\n2 For parsing to verify the syntactic correctness of the input source code and to produce parse tree (On Console)\n");
      printf("3 For printing the Abstract Syntax Tree (Inorder Traversal) \n4  For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree\n");
      printf("5 For printing the Symbol Table in appropriate format showing all relevant information\n");
      printf("6 For compiling to verify the syntactic and semantic correctness of the input source code\n");
      printf("7 For producing assembly code (only when there is no syntactic, semantic or type mismatch errors)");
      printf("\n8 to exit\nChoice: ");
      scanf("%d",&choice);
      printf("\n\n\n");
      //choice = 5;
      

      
      FILE *fp;
      switch(choice){
         case 1:
            fp = fopen(argv[1],"r");
            getStream(fp,buf[0]);
            do{
               temp = getNextToken(fp,buf,&begin,&forward,&currentBuf,&lineNo);
               

               if(temp->tokenId>0){
                  printf("%s %s %lu\n",temp->tokenName,temp->lexeme,temp->lineNo);
               }
            }
            while(temp->tokenId!=(int)t_DOLLAR);
            fclose(fp);

         break;

         case 2:
         	x = parseInputSourceCode(argv[1], parseTable, rules, termSetsArr,&err_flag_parse);
         	no_parse = countParseTree(x);
			printParseTree(x,NULL);
			parse_flag = 1;
         	
         	

            
         break;

         case 3:
         	if(parse_flag!=1){
         		printf("First choose option 2 to generate parse tree\n");
         	}
         	else{
         		parseTreeToAST(&x);
         		no_ast = countParseTree(x);
            	printf("Inorder Traversal of AST\n");
            	printParseTree(x,NULL);
            	ast_flag =1;
         	}
            
         break;

         case 4:
            if(ast_flag!=1){
            	printf("First choose option 3 to generate AST\n");
            }
            else{
            	printf("Parse Tree: Number of Nodes = %ld, Allocated Memory = %ld bytes\n",no_parse,(long int)(no_parse*sizeof(struct treeNod)));
				printf("AST       : Number of Nodes = %ld, Allocated Memory = %ld bytes\n",no_ast,(long int)(no_ast*sizeof(struct treeNod)));
				printf("Percent Compression = %f%%\n",(((float)no_parse-(float)no_ast)/(float)no_parse)*100.0);
            }
            // printParseTree(parseInputSourceCode(argv[1], parseTable, rules, termSetsArr,&err_flag_parse),argv[2]);
         break;


         case 5:
         	if(ast_flag!=1){
         		printf("First choose option 3 to generate AST\n");
         	}
         	else{
         		moduleScopeInfo some = initModuleScopeInfo();
         		nullifyHead();
            	populateSymbolTable(x,NULL,some);
            	actuallyPrintScopes();
         	}
         break;

         case 6:
         	x = parseInputSourceCode(argv[1], parseTable, rules, termSetsArr,&err_flag_parse);
			   if(err_flag_parse == 1){
				     break;
			   }
   			parseTreeToAST(&x);
   			nullifyHead();
   			some = initModuleScopeInfo();
            populateSymbolTable(x,NULL,some);
            printf("\n\nIf you see no errors on your screen, then congrats, your code compiled successfully\n");
         break;

         case 7:
         	printf("Works assuming code has no semantic or syntactic errors\n");
         	x = parseInputSourceCode(argv[1], parseTable, rules, termSetsArr,&err_flag_parse);
			if(err_flag_parse == 1){
				break;
			}
			parseTreeToAST(&x);
			nullifyHead();
			some = initModuleScopeInfo();
            populateSymbolTable(x,NULL,some);

            generateCode(x,argv[2]);
            printf("Code generated in %s\n",argv[2]);

         break;

         case 8:
         	exit(0);
         break;

         default: 
         	printf("Please enter a valid option\n");
         break;
            // x = parseInputSourceCode(argv[1], parseTable, rules, termSetsArr,&err_flag_parse);
            // if(err_flag_parse==1){
            // 	exit(0);
            // }
            // printParseTree(x,argv[2]);
            // parseTreeSize = countParseTree(x);
            // parseTreeToAST(&x);
            // ASTsize = countParseTree(x);
            // printf("\n_______________________________________________\n");
            // printParseTree(x,argv[2]);
            // moduleScopeInfo some = initModuleScopeInfo();
            // populateSymbolTable(x,NULL,some);
            // actuallyPrintScopes();
            // printf("\nSizes: %ld %ld\n",parseTreeSize*sizeof(treeNode),ASTsize*sizeof(treeNode));
            // printf("\n------------------------------------------------\n");
            // generateCode(x,"code.asm");
            // //printModuleScope(some);
            // exit(0);
        
      }
   }
   return 0;
}

// int main(int argc,char* argv[]){
// 	printf("1) FIRST and FOLLOW sets automated\n2)Both lexical and syntax analysis modules implemented\n");
// 	printf("3) Test case 1,3,4 working perfectly. Test case 2 has not been handled as per discussion with the instructor\n");
// 	printf("4) Parse Tree Generated\n");
// 	if(argc!=3){
// 		printf("Incorrect arguments\nTerminating driver\n");
// 		exit(1);
// 	}
// 	char file2[100];
// 	strcpy(file2,"testfile.txt");
// 	int choice;


// 	int i,j,currentBuf=0;
// 	long unsigned int lineNo = 1;
// 	char *buf[2], *forward, *begin;
	
	
// 	tokenInfo* temp;
// 	rule* rules[no_rules];
// 	populateRules(rules);
	
// 	term_sets* termSetsArr[no_tnt];
	
// 	for(i=0;i<no_tnt;i++){
// 		termSetsArr[i] = (term_sets*)malloc(sizeof(term_sets));
// 		termSetsArr[i]->FIRST = 0;
// 		termSetsArr[i]->FOLLOW = 0;
// 		termSetsArr[i]->token = (tnt)i;
// 	}
// 	int** parseTable;
// 	parseTable = (int**)malloc(sizeof(int*)*no_non_terminals);
// 	for(i=0;i<no_non_terminals;i++){
// 		parseTable[i] = (int*)malloc(sizeof(int)*no_terminals);
// 	}
// 	for(i=0;i<no_non_terminals;i++){
// 		for(j=0;j<no_terminals;j++){
// 			parseTable[i][j]=-1; //initializing parse table
// 		}
// 	}
// 	populateFIRST(rules,termSetsArr);
// 	populateFOLLOW(rules,termSetsArr);


// 	populateParseTable(parseTable,rules,termSetsArr);

// 	while(1){
// 		buf[0] = (char*)malloc(sizeof(char)*(bufferSize+1));
// 		buf[0][bufferSize]='\0';
// 		buf[1] = (char*)malloc(sizeof(char)*(bufferSize+1));
// 		buf[1][bufferSize]='\0';
// 		begin = buf[0];
// 		forward = buf[0];
// 		printf("Press\n1 For removal of comments and printing the comment free code on the console\n2 for printing the token list (on the console)\n");
// 		printf("3 for parsing to verify the syntactic correctness of the input source code\n4 for creating the parse tree and printing it appropriately");
// 		printf("\n5 to exit\nChoice: ");
// 		scanf("%d",&choice);
// 		switch(choice){
// 			case 1:
// 				removeComments(argv[1], file2);
// 				FILE *fp;
// 				fp = fopen(file2,"r");

// 				if(fp!=NULL){
// 					char ch;
// 					while((ch = fgetc(fp))!=EOF){
// 						putchar(ch);
// 					}
// 				}
// 				fclose(fp);

// 			break;

// 			case 2:
// 				fp = fopen(argv[1],"r");
// 				getStream(fp,buf[0]);
// 				do{
// 					temp = getNextToken(fp,buf,&begin,&forward,&currentBuf,&lineNo);
					

// 					if(temp->tokenId>0){
// 						printf("%s %s %lu\n",temp->tokenName,temp->lexeme,temp->lineNo);
// 					}
// 				}
// 				while(temp->tokenId!=(int)t_DOLLAR);
// 				fclose(fp);
// 			break;

// 			case 3:
// 				parseInputSourceCode(argv[1], parseTable, rules, termSetsArr);

// 			break;

// 			case 4:
// 				printParseTree(parseInputSourceCode(argv[1], parseTable, rules, termSetsArr),argv[2]);
// 			break;


// 			case 5:
// 				exit(0);
// 			break;


// 		}
// 	}




// 	return 0;
// }